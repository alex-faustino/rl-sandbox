"""Homework 1 Problem 3
Implementing an optimal control problem
that finds the minimum time to reach a state named 3
in a discrete-time, discrete state-space process"""
import gym
from gym import spaces
from gym.utils import seeding
import numpy as np
import random as rm

class optimalControl(gym.Env):
    metadata = {
            'render.modes': ['human', 'rgb_array']
            }
    def __init__(self):
        
        self.P_1_to_2 = 0.3
        self.P_2_to_2 = 0.7
        self.P_1_to_1 = 0.5
        self.P_2_to_1 = 0.5
        l = np.array([-0.25])
        h = np.array([0.25])
        self.action_space = spaces.Box(low = l, high = h, dtype = np.float32)
        self.state_space = spaces.Discrete(2)
        
        self.seed()
        self.viewer = None
        self.state = None
        
        self.steps_beyond_done = None
        
    def step(self, action):
        x = self.state
        
        if x == 0:
            A = [self.P_1_to_1+action, self.P_1_to_2-action ]
            c = np.random.choice(2,1,p=A)
            x = c[0]
        elif x == 1:
            A = [self.P_2_to_1, self.P_2_to_2]
            c = np.random.choice(2,1,p=A)
            x = c[0]
        
        reward = 0
        if x == 1:
            reward = 1
            
        self.state = x
        return np.array(self.state), reward, done. x
    
    def reset(self):
        self.state = env.state_space.sample()
        return np.array(self.state)
    
    def render(self, mode = 'human'):
        width = 250
        height = 250
        scale = 50
        state = self.state
        x = state
        
        if self.viewer is None:
            from gym.envs.classic_control import rendering
            self.viewer = rendering.Viewer(width, height)
            for i in range(6):
                l1_x = i*scale
                l1_y = 0
                l2_x = i*scale
                l2_y = 5*scale
                line = self.viewer.draw_line((l1_x,l1_y),(l2_x,l2_y))
                self.viewer.add_geom(line)
                
            for i in range(6):
                l1_x = 0
                l1_y = i*scale
                l2_x = 5*scale
                l2_y = i*scale
                line = self.viewer.draw_line((l1_x,l1_y),(l2_x,l2_y))
                self.viewer.add_geom(line)
            
            a_s = 15
            l, r, t, b = -a_s, a_s, a_s, -a_s
            agent = rendering.FilledPolygon([(l,b), (l,t), (r,t), (r,b)])
            self.agent_trans = rendering.Transform()
            agent.add_attr(self.agent_trans)
            agent.set_color(0.5,0.5,0.5)
            self.viewer.add_geom(agent)
            
        if self.state is None:
            return None
        y1 = 1
        x1 = x+1
        self.agent_trans.set_translation((x1-0.25)*50, (y1-0.25)*50)
        return self.viewer.render(return_rgb_array=mode=='rgb_array')
    
    def close(self):
        if self.viewer:self.viewer.close()
        
env = optimalControl()
for i in range(20):
    obs = env.reset()
    rew = 0
    for t in range(1000):
        env.render()
        action = env.action_space.sample()
        obs, reward, done, st = env.step(action)
        print(st)
        rew = rew  + reward^2
        if done:
            print('Finished')
            break
     
    rew = rew - 0.5*reward
    env.close()
        
                
    
        
        
        
        
